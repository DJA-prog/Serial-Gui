# Debug Detection Examples for Serial Communication Monitor
# =========================================================
# Since PyInstaller doesn't have preprocessor directives like GCC,
# here are different approaches to handle debug/release builds:

## Method 1: Check version string for 'd' suffix
# Add this to App.py after the __version__ line:

IS_DEBUG = __version__.endswith('d')

# Then use it throughout your code:
if IS_DEBUG:
    print(f"Debug mode active - Version: {__version__}")
    # Enable verbose logging
    # Show additional debug UI elements
    # etc.


## Method 2: Environment variable (set during build)
# This would require modifying the build script to set an env var
# and bundling it into the executable, but it's more explicit:

import os
IS_DEBUG = os.environ.get('APP_BUILD_MODE', 'release') == 'debug'


## Method 3: Check if running from PyInstaller bundle
# Already partially implemented in your code via get_resource_path()
# You can extend this:

def is_frozen():
    """Check if running as PyInstaller executable"""
    return getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS')

def is_debug_build():
    """Detect if this is a debug build"""
    # Check version suffix
    if __version__.endswith('d'):
        return True
    # Could also check for debug-specific files or markers
    return False


## Method 4: Create a build-time configuration file
# During build, generate a config.py with build information:

# build_config.py (generated by build script)
BUILD_MODE = "debug"  # or "release"
BUILD_DATE = "2026-02-07"
BUILD_VERSION = "2.5.0d"


## Practical Example Usage in App.py:
"""
# At the top of App.py, after imports:

# Application version
__version__ = "2.5.0"

# Debug mode detection
IS_DEBUG = __version__.endswith('d')

# Configure logging based on build mode
if IS_DEBUG:
    import logging
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
else:
    import logging
    logging.basicConfig(level=logging.ERROR)

# In your main application class:
class SerialCommunicationMonitor(QMainWindow):
    def __init__(self):
        super().__init__()
        
        if IS_DEBUG:
            # Show version in window title for debug builds
            self.setWindowTitle(f"Serial Monitor {__version__} [DEBUG]")
            # Enable additional debug features
            self.enable_debug_features()
        else:
            self.setWindowTitle(f"Serial Monitor {__version__}")
        
    def enable_debug_features(self):
        # Add debug-specific UI elements
        # Enable verbose logging
        # Show performance metrics
        pass
"""


## How to use the build scripts:

# Windows PowerShell:
# Release build: .\build_windows.ps1 release
# Debug build:   .\build_windows.ps1 debug
# (or just .\build_windows.ps1 which defaults to release)

# Linux Bash:
# Release build: ./build_linux.sh release
# Debug build:   ./build_linux.sh debug

# The debug builds will have:
# - Version with 'd' suffix (e.g., 2.5.0d)
# - Console window visible (--console flag)
# - PyInstaller debug output (--debug=all)
# - Executable name includes version suffix
